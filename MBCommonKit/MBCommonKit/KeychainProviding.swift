//
//  Copyright Â© 2019 MBition GmbH. All rights reserved.
//

import Foundation

// MARK: - Shared Keychain Types

public typealias KeychainAccessGroup = String

public enum KeychainLocation {
    
    case local
    case shared(KeychainAccessGroup)
}


// MARK: - Error Type

public enum KeychainError: Error, CustomStringConvertible {
    case typeNotSupportedError

    public var description: String {

        switch self {
        case .typeNotSupportedError:
            return "Currently only values of type String and Data are supported"
        }
    }
}


/**
 The type used for the key of a Keychain entry.
 */
public struct KeychainKey {

    public let name: String
    public let accessibility: String?

    public init(name: String, accessibility: String? = nil) {
        self.name = name
        self.accessibility = accessibility
    }
}


// MARK: - Keychain Protocol

public protocol KeychainProviding {

    static var service: String { get }
	
    func get<T>(for key: KeychainKey, from location: KeychainLocation?) throws -> T?
    func set<T>(_ value: T, for key: KeychainKey, from location: KeychainLocation?) throws
    func remove(for key: KeychainKey, from location: KeychainLocation?) throws
    func clear(_ location: KeychainLocation?) throws
}


// MARK: - Realm Extension

extension KeychainProviding {

    private static var realmKeychainIdentifier: String {
        return "MBRS.Daimler.Realm.EncryptionKey"
    }

	public static var realmEncryptionKey: Data? {

        // Identifier for our keychain entry - should be unique for your application
        guard let keychainIdentifierData = self.realmKeychainIdentifier.data(using: String.Encoding.utf8, allowLossyConversion: false) else {
            return nil
        }

        // First check in the keychain for an existing key
        let baseQuery: [NSString: AnyObject] = [
            kSecClass: kSecClassKey,
            kSecAttrApplicationTag: keychainIdentifierData as AnyObject,
            kSecAttrKeySizeInBits: 512 as AnyObject
        ]
        let query: [NSString: AnyObject] = baseQuery.merging([
            kSecReturnData: true as AnyObject
        ]) {(current, _) in current}

        // To avoid Swift optimization bug, should use withUnsafeMutablePointer() function to retrieve the keychain item
        // See also: http://stackoverflow.com/questions/24145838/querying-ios-keychain-using-swift/27721328#27721328
        var dataTypeRef: AnyObject?
        var status = withUnsafeMutablePointer(to: &dataTypeRef) { SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0)) }
        if status == errSecSuccess {
            //update legacy keys without kSecAttrAccessibleAfterFirstUnlock
            if let dataDeref = dataTypeRef as? Data {
                //https://stackoverflow.com/questions/5369238/is-it-possible-to-update-a-keychain-items-ksecattraccessible-value
                /**this will change the keychain access restriction from
                 * kSecAttrAccessibleWhenUnlocked (default for keys generated by older versions of this library)
                 * to kSecAttrAccessibleAfterFirstUnlock (necessary for background launches)
                 * when the app (with this library updated) is launched for the first
                 * time in the foreground */
                let performChangeAccess: Bool = {
                    /**target *only* situations where the current access restriction is
                     * kSecAttrAccessibleWhenUnlocked (ios default when nothing is set)
                     *
                     * do nothing in all other situations to prevent runaway overwrites in case someone (in the future) explitly
                     * wants to set a different access restriction*/
                    let accessQuery: [NSString: AnyObject] = baseQuery.merging([
                        kSecReturnAttributes: true as AnyObject
                    ]) {(current, _) in current}
                    var attributeRef: AnyObject?
                    var _ = withUnsafeMutablePointer(to: &attributeRef) { SecItemCopyMatching(accessQuery as CFDictionary, UnsafeMutablePointer($0)) }
                    if let attributes = attributeRef as? [NSString: AnyObject],
                       let acc = attributes[kSecAttrAccessible] {
                        if CFGetTypeID(acc) == CFStringGetTypeID() {
                            if acc as! CFString == kSecAttrAccessibleWhenUnlocked {
                                return true
                            }
                        }
                    }
                    return false
                }()
                
                if performChangeAccess {
                    let entryAccessUpdate: [NSString: AnyObject] = [
                        kSecValueData: dataDeref as AnyObject,
                        kSecAttrAccessible: kSecAttrAccessibleAfterFirstUnlock as AnyObject
                    ]
                    SecItemUpdate(baseQuery as CFDictionary, entryAccessUpdate as CFDictionary)
                }
            }
            
            return dataTypeRef as? Data
        }

        // No pre-existing key from this application, so generate a new one
        var keyData = Data(count: 64)
        let keyDataCount = keyData.count
        let result = keyData.withUnsafeMutableBytes { (bytes) in
            SecRandomCopyBytes(kSecRandomDefault, keyDataCount, bytes)
        }
        assert(result == 0, "Failed to get random bytes")

        // Store the key in the keychain
        let newQuery: [NSString: AnyObject] = baseQuery.merging([
            kSecValueData: keyData as AnyObject,
            kSecAttrAccessible: kSecAttrAccessibleAfterFirstUnlock as AnyObject
        ]) {(current, _) in current}

        status = SecItemAdd(newQuery as CFDictionary, nil)
        assert(status == errSecSuccess, "Failed to insert the new key in the keychain")

        return keyData
    }
}


// MARK: - KeychainProviderArchetype

final public class KeychainProviderArchetype: KeychainProviding {
	
	// MARK: - Init
	
	public init() {}
	
	
	// MARK: - KeychainProviding
	
	public static var service: String {
		fatalError("This is a placeholder implementation. Please implement your own keychain handling class or use the implementation from MBMobileSDK")
	}
	
	public func get<T>(for key: KeychainKey, from location: KeychainLocation?) throws -> T? {
		fatalError("This is a placeholder implementation. Please implement your own keychain handling class or use the implementation from MBMobileSDK")
	}
	
	public func set<T>(_ value: T, for key: KeychainKey, from location: KeychainLocation?) throws {
		fatalError("This is a placeholder implementation. Please implement your own keychain handling class or use the implementation from MBMobileSDK")
	}
	
	public func remove(for key: KeychainKey, from location: KeychainLocation?) throws {
		fatalError("This is a placeholder implementation. Please implement your own keychain handling class or use the implementation from MBMobileSDK")
	}
	
	public func clear(_ location: KeychainLocation?) throws {
		fatalError("This is a placeholder implementation. Please implement your own keychain handling class or use the implementation from MBMobileSDK")
	}
}
